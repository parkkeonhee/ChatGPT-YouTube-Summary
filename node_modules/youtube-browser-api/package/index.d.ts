export { _GET as query, type Query as QueryParams, } from './routes/query/+server';
export { _GET as transcript, type Query as TranscriptParams, } from './routes/transcript/+server';
export { _GET as content, type Params as ContentParams, } from './routes/content/+server';
export { _GET as data, type Query as DataParams, type Slug as DataSlug, } from './routes/data/[endpoint]/+server';
declare const _default: {
    query: <Q extends import("./routes/query/+server").Query & import("./routes/zero-api/fetch").Patch>(query: Q & import("./routes/query/+server").Query & import("./routes/zero-api/fetch").Patch) => Promise<{
        manual: Q["manual"];
    } extends {
        manual: true;
    } ? (Omit<Omit<Response, "json">, "ok"> & {
        json: () => Promise<import("./routes/query/flatten").MapSchema<Q["schema"], Q["verbose"], Q["tsAny"]>>;
        ok: true;
    }) | {
        body: {
            errors: {
                readonly id?: "Must be 11 characters" | undefined;
                readonly query?: "paths or schema should be present and typed accordingly" | undefined;
            };
            message: "Visualize the query process https://excalidraw.com/#json=0hDFTajVxa2oO7s34kMef,M_jPO1x4IoE_Eqz2RGvPVA";
        };
        status: 400;
        ok: false;
    } : import("./routes/query/flatten").MapSchema<Q["schema"], Q["verbose"], Q["tsAny"]>>;
    transcript: <Q_1 extends {
        playlistId?: string | undefined;
        videoId?: string | undefined;
    } & import("./routes/zero-api/fetch").Patch>(query: Q_1 & import("./routes/zero-api/fetch").Patch) => Promise<Q_1 extends {
        manual: true;
    } ? {
        body: {
            errors: {
                readonly query?: "Empty Params: try with a videoId or playlistId" | undefined;
            };
            message: string;
        };
        status: 400;
        ok: false;
    } | (Omit<Omit<Response, "json">, "ok"> & {
        json: () => Promise<{ [key in keyof Q_1]: {
            videoId: void | import("./routes/transcript/transcript").TranscriptResponse[];
            playlistId: void | (import("./routes/transcript/transcript").TranscriptResponse[] | undefined)[];
        }[key & keyof {
            playlistId?: string | undefined;
            videoId?: string | undefined;
        }]; }>;
        ok: true;
    }) : Awaited<{ [key in keyof Q_1]: {
        videoId: void | import("./routes/transcript/transcript").TranscriptResponse[];
        playlistId: void | (import("./routes/transcript/transcript").TranscriptResponse[] | undefined)[];
    }[key & keyof {
        playlistId?: string | undefined;
        videoId?: string | undefined;
    }]; }>>;
    content: <R extends ["isLive" | "title" | "channel" | "description" | "initialData" | "playerResponse" | "apiToken" | "context" | "transcriptMeta" | "auto_chapters" | "chapters" | "macro_chapters" | "key_chapters" | "heatmap" | "id" | "suggestions" | "storyboard" | "heatmapPath" | "movingThumbnail", ...("isLive" | "title" | "channel" | "description" | "initialData" | "playerResponse" | "apiToken" | "context" | "transcriptMeta" | "auto_chapters" | "chapters" | "macro_chapters" | "key_chapters" | "heatmap" | "id" | "suggestions" | "storyboard" | "heatmapPath" | "movingThumbnail")[]], P extends import("./routes/zero-api/fetch").Patch>(query: {
        id: string;
    } & {
        params: R;
    } & P & import("./routes/zero-api/fetch").Patch) => Promise<P extends {
        manual: true;
    } ? {
        body: {
            errors: {
                readonly id?: "Must be 11 characters" | undefined;
                readonly query?: "Empty or undefined parameters" | undefined;
            };
            message: string;
        };
        status: 400;
        ok: false;
    } | (Omit<Omit<Response, "json">, "ok"> & {
        json: () => Promise<{ [key_1 in R[number]]: {
            movingThumbnail?: string | undefined;
            storyboard?: {
                storyboard: {
                    url: string[];
                    parts: {
                        firstPart: string;
                        secondPart: string;
                    };
                    keys: {
                        sgp: string;
                        sigh: string | undefined;
                    };
                };
                timeline: Record<"low" | "medium" | "high", {
                    slot: {
                        templateUrl: string;
                        url: string;
                        thumbnailWidth: number;
                        thumbnailHeight: number;
                        thumbnailCount: number;
                        interval: number;
                        columns: number;
                        rows: number;
                        storyboardCount: number;
                    };
                    frames: {
                        rows: number;
                        columns: number;
                        url: string;
                        thumbnailCount: number;
                        width: number;
                        height: number;
                    }[];
                }>;
            } | undefined;
            heatmapPath?: string | undefined;
            suggestions?: {
                id: string;
                type: string;
                thumbnail: import("./routes/data/types/initial-data").Thumbnail5[];
                title: string;
                channelTitle: string;
                shortBylineText: string;
                length: import("./routes/data/types/initial-data").LengthText;
                isLive: boolean;
            }[] | undefined;
            initialData?: import("./routes/data/types/initial-data").InitialData | undefined;
            playerResponse?: import("./routes/data/types/player-response").PlayerResponse | undefined;
            apiToken?: string | undefined;
            context?: import("./routes/data/types/initial-data").Context | undefined;
            transcriptMeta?: {
                key: string | undefined;
                params: string | undefined;
                visitorData: string | undefined;
                sessionId: string | undefined;
                clickTrackingParams: string | undefined;
            } | undefined;
            auto_chapters?: import("./routes/data/types/initial-data").Chapter[] | undefined;
            chapters?: import("./routes/data/types/initial-data").Chapter[] | undefined;
            macro_chapters?: {
                chapter: import("./routes/data/types/initial-data").RepeatChapterCommand2 | undefined;
                thumbnails: import("./routes/data/types/initial-data").Thumbnail13[];
                title: import("./routes/data/types/initial-data").Title11;
                description: import("./routes/data/types/initial-data").TimeDescription;
            }[] | undefined;
            key_chapters?: {
                tittle: import("./routes/data/types/initial-data").Title11;
                thumbnails: import("./routes/data/types/initial-data").Thumbnail13[] | null | undefined;
                chapter: {
                    startTimeMs: string;
                    durationTimeMs: string;
                };
            }[] | undefined;
            heatmap?: import("./routes/data/types/initial-data").HeatmapRenderer | undefined;
            title?: string | undefined;
            isLive?: boolean | undefined;
            channel?: string | undefined;
            description?: string | undefined;
        }[key_1 & ("isLive" | "title" | "channel" | "description" | "initialData" | "playerResponse" | "apiToken" | "context" | "transcriptMeta" | "auto_chapters" | "chapters" | "macro_chapters" | "key_chapters" | "heatmap" | "suggestions" | "storyboard" | "heatmapPath" | "movingThumbnail")]; }>;
        ok: true;
    }) : Awaited<{ [key_1 in R[number]]: {
        movingThumbnail?: string | undefined;
        storyboard?: {
            storyboard: {
                url: string[];
                parts: {
                    firstPart: string;
                    secondPart: string;
                };
                keys: {
                    sgp: string;
                    sigh: string | undefined;
                };
            };
            timeline: Record<"low" | "medium" | "high", {
                slot: {
                    templateUrl: string;
                    url: string;
                    thumbnailWidth: number;
                    thumbnailHeight: number;
                    thumbnailCount: number;
                    interval: number;
                    columns: number;
                    rows: number;
                    storyboardCount: number;
                };
                frames: {
                    rows: number;
                    columns: number;
                    url: string;
                    thumbnailCount: number;
                    width: number;
                    height: number;
                }[];
            }>;
        } | undefined;
        heatmapPath?: string | undefined;
        suggestions?: {
            id: string;
            type: string;
            thumbnail: import("./routes/data/types/initial-data").Thumbnail5[];
            title: string;
            channelTitle: string;
            shortBylineText: string;
            length: import("./routes/data/types/initial-data").LengthText;
            isLive: boolean;
        }[] | undefined;
        initialData?: import("./routes/data/types/initial-data").InitialData | undefined;
        playerResponse?: import("./routes/data/types/player-response").PlayerResponse | undefined;
        apiToken?: string | undefined;
        context?: import("./routes/data/types/initial-data").Context | undefined;
        transcriptMeta?: {
            key: string | undefined;
            params: string | undefined;
            visitorData: string | undefined;
            sessionId: string | undefined;
            clickTrackingParams: string | undefined;
        } | undefined;
        auto_chapters?: import("./routes/data/types/initial-data").Chapter[] | undefined;
        chapters?: import("./routes/data/types/initial-data").Chapter[] | undefined;
        macro_chapters?: {
            chapter: import("./routes/data/types/initial-data").RepeatChapterCommand2 | undefined;
            thumbnails: import("./routes/data/types/initial-data").Thumbnail13[];
            title: import("./routes/data/types/initial-data").Title11;
            description: import("./routes/data/types/initial-data").TimeDescription;
        }[] | undefined;
        key_chapters?: {
            tittle: import("./routes/data/types/initial-data").Title11;
            thumbnails: import("./routes/data/types/initial-data").Thumbnail13[] | null | undefined;
            chapter: {
                startTimeMs: string;
                durationTimeMs: string;
            };
        }[] | undefined;
        heatmap?: import("./routes/data/types/initial-data").HeatmapRenderer | undefined;
        title?: string | undefined;
        isLive?: boolean | undefined;
        channel?: string | undefined;
        description?: string | undefined;
    }[key_1 & ("isLive" | "title" | "channel" | "description" | "initialData" | "playerResponse" | "apiToken" | "context" | "transcriptMeta" | "auto_chapters" | "chapters" | "macro_chapters" | "key_chapters" | "heatmap" | "suggestions" | "storyboard" | "heatmapPath" | "movingThumbnail")]; }>>;
    data: <S extends "channel" | "playlist" | "suggestion" | "search", Q_2 extends (NonNullable<{
        readonly playlist?: {
            playlistId: string;
            limit: number;
        } | undefined;
        readonly channel?: {
            channelId: string;
        } | undefined;
        readonly suggestion?: {
            limit: number;
        } | undefined;
        readonly search?: {
            keyword: string;
            withPlaylist?: boolean | undefined;
            limit?: number | undefined;
            option?: "" | "channel" | "playlist" | "video" | "movie" | undefined;
        } | undefined;
    }[S]> extends infer T ? { [K in keyof T]: NonNullable<{
        readonly playlist?: {
            playlistId: string;
            limit: number;
        } | undefined;
        readonly channel?: {
            channelId: string;
        } | undefined;
        readonly suggestion?: {
            limit: number;
        } | undefined;
        readonly search?: {
            keyword: string;
            withPlaylist?: boolean | undefined;
            limit?: number | undefined;
            option?: "" | "channel" | "playlist" | "video" | "movie" | undefined;
        } | undefined;
    }[S]>[K]; } : never) & import("./routes/zero-api/fetch").Patch>(slug: S, query: Q_2 & import("./routes/zero-api/fetch").Patch) => Promise<Q_2 extends {
        manual: true;
    } ? {
        body: {
            errors: {
                readonly query?: "Invalid slug, should be either: playlist, channel, suggestion or search" | undefined;
            };
            message: string;
        };
        status: 400;
        ok: false;
    } | (Omit<Omit<Response, "json">, "ok"> & {
        json: () => Promise<ReturnType<{
            readonly playlist: (params: {
                playlistId: string;
                limit: number;
            }) => Promise<{
                items: import("./routes/types").ITEM[];
                metadata: import("./routes/data/types/initial-data").MetaData;
            } | undefined>;
            readonly channel: typeof import("./routes/content/channel").GetChannelById;
            readonly suggestion: typeof import("./routes/data/suggest").GetSuggestData;
            readonly search: typeof import("./routes/data/keyword").GetListByKeyword;
        }[S]>>;
        ok: true;
    }) : Awaited<ReturnType<{
        readonly playlist: (params: {
            playlistId: string;
            limit: number;
        }) => Promise<{
            items: import("./routes/types").ITEM[];
            metadata: import("./routes/data/types/initial-data").MetaData;
        } | undefined>;
        readonly channel: typeof import("./routes/content/channel").GetChannelById;
        readonly suggestion: typeof import("./routes/data/suggest").GetSuggestData;
        readonly search: typeof import("./routes/data/keyword").GetListByKeyword;
    }[S]>>>;
};
export default _default;
