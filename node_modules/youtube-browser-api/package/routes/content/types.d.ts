export type Return<T extends (...args: any) => any> = {
    [key in keyof Partial<Awaited<ReturnType<T>>>]?: boolean;
};
type ValuesOf<T> = T[keyof T];
type ObjectValuesOf<T> = Exclude<Extract<ValuesOf<T>, object>, Array<any>>;
type NonObjectKeysOf<T> = {
    [K in keyof T]: T[K] extends Array<any> ? K : T[K] extends object ? never : K;
}[keyof T];
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
export type Flatten<T> = Pick<T, NonObjectKeysOf<T>> & UnionToIntersection<ObjectValuesOf<T>>;
export type DeepFlatten<T> = T extends any ? Pick<T, NonObjectKeysOf<T>> & UnionToIntersection<DeepFlatten<ObjectValuesOf<T>>> : never;
export type FirstFlatten<T> = Omit<DeepFlatten<T>, keyof T>;
export type Union<T> = {
    [K in keyof T]: {
        [K2 in K]: T[K2];
    };
}[keyof T];
export type TupleUnion<U extends string, R extends any[] = []> = {
    [S in U]: Exclude<U, S> extends never ? [...R, S] : TupleUnion<Exclude<U, S>, [...R, S]>;
}[U];
export {};
