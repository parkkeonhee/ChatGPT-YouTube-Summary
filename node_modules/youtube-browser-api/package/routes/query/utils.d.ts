import type { Prettify } from '../utility-types';
type Partial = undefined | true;
type OptionalArrayOr<T, Otherwise> = T extends ArrayLike<any> ? {
    [index: number]: DeepPartial<T[number]> | Partial;
} | Partial : Otherwise;
type OptionalUndefinedOr<T, Otherwise> = T extends Partial ? Partial : Otherwise;
type OptionalNullOr<T, Otherwise> = T extends null ? null | Partial : Otherwise;
type OptionalStringOr<T, Otherwise> = T extends string ? T | Partial : Otherwise;
type OptionalNumberOr<T, Otherwise> = T extends number ? T | Partial : Otherwise;
type OptionalBooleanOr<T, Otherwise> = T extends boolean ? boolean | Partial : Otherwise;
export type DeepPartial<T> = OptionalStringOr<T, OptionalNumberOr<T, OptionalBooleanOr<T, OptionalNullOr<T, OptionalUndefinedOr<T, OptionalArrayOr<T, T extends object ? {
    [Key in keyof T]?: DeepPartial<T[Key]> | Partial;
} : Partial>>>>>>;
type N = null | undefined;
type Clear<T> = NonNullable<Exclude<T, N>>;
type JSON = Record<string | number, any>;
type PathImpl<T, K extends keyof T> = K extends string | number ? T[K] extends {
    end: true;
} ? K : T[K] extends JSON ? T[K] extends ArrayLike<any> ? `${K}.${PathImpl<T[K], number>}` : K | `${K}.${PathImpl<T[K], keyof T[K]>}` : T[K] extends JSON | N ? T[K] extends ArrayLike<any> | N ? `${K}?.${PathImpl<Clear<T[K]>, number>}` : K | `${K}?.${PathImpl<Clear<T[K]>, keyof Clear<T[K]>>}` : K : never;
export type NonNullableNested<T> = {
    [P in keyof T]-?: Prettify<Exclude<NonNullableNested<T[P]>, null | undefined>>;
};
export type PathValue<T, P extends Path<T>> = P extends `${infer NlC}.${infer Rest}` ? NlC extends `${infer Key}?` ? PathValue<Clear<T[Key]>, Rest> : PathValue<T[NlC], Rest> : P extends `${infer Key}.${infer Rest}` ? Key extends keyof T ? Rest extends Path<T[Key]> ? PathValue<T[Key], Rest> : T[Key] extends ArrayLike<any> ? PathValue<T[Key], Key & number> : never : PathValue<T[Key], Rest> : P extends keyof T ? T[P] : never;
export type Path<T> = PathImpl<T, keyof T> | keyof T;
export declare const pick: any;
export declare class Deferred<T, E = unknown> {
    promise: Promise<T>;
    resolve: (value: T | PromiseLike<T>) => void;
    reject: (reason?: E) => void;
    constructor();
}
export {};
