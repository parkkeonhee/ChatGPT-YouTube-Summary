import * as HTTP from './http';
import type { StatusText } from './statusCode';
import type { Simplify, UnionToIntersection } from './utility.js';
type Type = 'string' | 'number' | 'bigint' | 'boolean' | 'symbol' | 'undefined' | 'object' | 'function';
export declare const err: {
    handler<E extends (Record<any, any> | null)[]>(...args: E): (<K extends Readonly<"BadRequest" | "Unauthorized" | "PaymentRequired" | "Forbidden" | "NotFound" | "MethodNotAllowed" | "NotAcceptable" | "ProxyAuthenticationRequired" | "RequestTimeout" | "Conflict" | "Gone" | "LengthRequired" | "PreconditionFailed" | "PayloadTooLarge" | "URITooLong" | "UnsupportedMediaType" | "RangeNotSatisfiable" | "ExpectationFailed" | "ImATeapot" | "MisdirectedRequest" | "UnprocessableEntity" | "Locked" | "FailedDependency" | "TooEarly" | "UpgradeRequired" | "PreconditionRequired" | "TooManyRequests" | "RequestHeaderFieldsTooLarge" | "UnavailableForLegalReasons" | "InternalServerError" | "NotImplemented" | "BadGateway" | "ServiceUnavailable" | "GatewayTimeout" | "HTTPVersionNotSupported" | "VariantAlsoNegotiates" | "InsufficientStorage" | "LoopDetected" | "NotExtended" | "NetworkAuthenticationRequired">, T extends Parameters<(typeof HTTP)[K]>[0] = {}, const M = string>(response: K, payload?: {
        options?: T | undefined;
        message?: M | undefined;
    } | undefined) => HTTP.CreateResponse<K, StatusText[K], false, {
        body: {
            errors: Simplify<UnionToIntersection<NonNullable<E[number]>>>;
            message: M extends undefined ? never : M;
        };
    } & T>) | null;
    /** Results in error if value(s) are undefined or null */
    require<T_1 extends Record<any, any>>(obj: T_1, errorMessage?: string): { [P in keyof T_1]?: string | undefined; } | null;
    /** If conditions aren't met, will result it errors specified */
    test<const K_1 extends Record<any, string>>(condition: any, obj: K_1): Partial<K_1> | null;
    /** Ignores undefined/null values — checks if the value of each key is a specified type */
    type<T_2 extends Record<any, any>>(obj: T_2, typing: Type | { [K_2 in keyof T_2]: Type; }): { [P_1 in keyof T_2]?: string | undefined; } | null;
    /** Ignores undefined/null values — if value(s) does not match, will result in error. */
    match<T_3 extends Record<any, any>>(obj: T_3, regex: RegExp | Record<keyof T_3, RegExp>, errorMsg: string): { [P_2 in keyof T_3]?: string | undefined; } | null;
};
export {};
