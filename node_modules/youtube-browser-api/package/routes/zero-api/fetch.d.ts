export declare class ClassErrPromise<TSuccess, TError> extends Promise<TSuccess> {
    constructor(executor: (resolve: (value: TSuccess | PromiseLike<TSuccess>) => void, reject: (reason: TError) => void) => void);
}
export interface ErrPromise<TSuccess, TError> {
    then<TResult1 = TSuccess, TResult2 = never>(onfulfilled?: ((value: TSuccess) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: TError) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    catch<TResult = never>(onrejected?: ((reason: TError) => TResult | PromiseLike<TResult>) | undefined | null): Promise<TSuccess | TResult>;
}
export declare function json<data = unknown, Ok = true>(params: data): Omit<Omit<Response, "json">, "ok"> & {
    json: () => Promise<data>;
    ok: Ok;
};
type FetchQuery = Record<string, any>;
export type Patch = {
    /**
     * Get access to the Response Object
     * ```
     * endpoint({...}).then(res=>{
     * 	if(!res.ok){
     * 		// ...
     * 	}
     * 	return res.json()
     * })
     * ```
     */
    manual?: boolean;
};
export declare const config: {
    baseUrl: string;
};
export declare function patchFetch<R extends object, P extends Patch, promise extends object>(params: {
    endpoint: Endpoint<R>;
    slug?: string;
    query: FetchQuery & Patch;
}): Promise<P extends {
    manual: true;
} ? Awaited<promise> : Awaited<ReturnType<Extract<Awaited<promise>, Omit<Omit<Response, "json">, "ok"> & {
    json: () => Promise<any>;
    ok: true;
}>["json"]>>>;
export type Endpoint<R> = Parameters<R>[0]['route']['id'] extends `/${infer endpoint}` ? endpoint extends `${infer endpoint2}/${string}` ? endpoint2 : endpoint : never;
export {};
